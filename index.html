<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>Pixel Castle RPG</title>
<style>
body { margin:0; background:#111; display:flex; justify-content:center; align-items:center; height:100vh; }
canvas { image-rendering:pixelated; border:4px solid #444; }
#dialog { position:absolute; bottom:10px; left:50%; transform:translateX(-50%);
  width:320px; padding:8px; background:rgba(0,0,0,0.85); color:#fff;
  font-family:monospace; font-size:12px; display:none; border:2px solid #888; }
</style>
</head>
<body>
<canvas id="game" width="320" height="180"></canvas>
<div id="dialog"></div>
<script src="js/game.js"></script>
</body>
</html>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const TILE = 16;
let currentMap = "hall";

/* ===== 地圖資料 ===== */
const maps = {
 hall:[
  "####################",
  "#.................>#",
  "#..######..........#",
  "#....##............#",
  "#........#####.....#",
  "#..................#",
  "####################",
  "####################",
  "####################",
  "####################"
 ],
 corridor:[
  "####################",
  "#<.................#",
  "#.......#..........#",
  "#.......#..........#",
  "#..................#",
  "#........>.........#",
  "####################",
  "####################",
  "####################",
  "####################"
 ]
};

/* ===== 載入 sprite PNG ===== */
const spritePlayer = new Image(); spritePlayer.src = "sprites/player.png";
const spriteNPC = new Image(); spriteNPC.src = "sprites/npc.png";
const spriteTiles = new Image(); spriteTiles.src = "sprites/tileset.png";
const spriteObjects = new Image(); spriteObjects.src = "sprites/objects.png";

/* ===== 玩家 ===== */
const player = {x:TILE*2, y:TILE*2, w:16, h:16, dir:"down", frame:0, animTimer:0, moving:false};

/* ===== NPC ===== */
const npcs=[
 {x:TILE*10, y:TILE*2, w:16, h:16, dir:"down", frame:0, msg:["你好，我是守衛"], route:[{x:10,y:2},{x:10,y:4}], routeIndex:0, routeTimer:0, room:"hall"}
];

/* ===== 互動物件 ===== */
const items=[
 {x:TILE*5, y:TILE*2, w:16, h:16, name:"書", msg:"這是一本古老的書", room:"hall"}
];

/* ===== 對話框 ===== */
const dialog = document.getElementById("dialog");

/* ===== 鍵盤 ===== */
const keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

/* ===== 主迴圈 ===== */
function loop(){update();draw();requestAnimationFrame(loop);}

/* ===== 更新 ===== */
function update(){
  let nx=player.x, ny=player.y; player.moving=false;
  if(keys["ArrowUp"]||keys["w"]){ny-=1; player.dir="up"; player.moving=true;}
  if(keys["ArrowDown"]||keys["s"]){ny+=1; player.dir="down"; player.moving=true;}
  if(keys["ArrowLeft"]||keys["a"]){nx-=1; player.dir="left"; player.moving=true;}
  if(keys["ArrowRight"]||keys["d"]){nx+=1; player.dir="right"; player.moving=true;}
  if(!isWall(nx,ny)) {player.x=nx; player.y=ny;}
  animatePlayer();
  updateNPCs();
  checkExit();
  checkItems();
}

/* ===== 動畫 ===== */
function animatePlayer(){if(!player.moving){player.frame=0; return;}
  player.animTimer++; if(player.animTimer>10){player.frame=(player.frame+1)%2; player.animTimer=0;}}

/* ===== 碰撞 ===== */
function isWall(x,y){
  const map = maps[currentMap];
  const left=Math.floor(x/TILE), right=Math.floor((x+player.w-1)/TILE);
  const top=Math.floor(y/TILE), bottom=Math.floor((y+player.h-1)/TILE);
  for(let ty=top; ty<=bottom; ty++){ for(let tx=left; tx<=right; tx++){
    if(map[ty] && map[ty][tx]==="#") return true;
  }} return false;
}

/* ===== 場景切換 ===== */
function checkExit(){
  const map = maps[currentMap]; const tx=Math.floor(player.x/TILE); const ty=Math.floor(player.y/TILE);
  const tile = map[ty][tx];
  if(tile==">"){ if(currentMap==="hall"){currentMap="corridor"; player.x=TILE*2;} }
  if(tile=="<"){ if(currentMap==="corridor"){currentMap="hall"; player.x=TILE*17;} }
}

/* ===== NPC ===== */
function updateNPCs(){
  npcs.forEach(npc=>{
    if(npc.room!==currentMap) return;
    if(npc.route.length>1){
      npc.routeTimer++; if(npc.routeTimer>60){
        npc.routeIndex=(npc.routeIndex+1)%npc.route.length;
        npc.x=npc.route[npc.routeIndex].x*TILE; npc.y=npc.route[npc.routeIndex].y*TILE;
        npc.routeTimer=0;
      }
    }
    if(Math.abs(player.x-npc.x)<16 && Math.abs(player.y-npc.y)<16 && keys[" "]){
      dialog.style.display="block"; dialog.innerText=npc.msg[0];
    }
  });
}

/* ===== 互動物件 ===== */
function checkItems(){
  items.forEach(item=>{
    if(item.room!==currentMap) return;
    if(Math.abs(player.x-item.x)<16 && Math.abs(player.y-item.y)<16 && keys[" "]){
      dialog.style.display="block"; dialog.innerText=item.msg;
    }
  });
}

/* ===== 繪圖 ===== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawMap(); drawItems(); drawNPCs(); drawPlayer();
}

function drawMap(){
  const map = maps[currentMap];
  for(let y=0;y<map.length;y++){
    for(let x=0;x<map[y].length;x++){
      let tile=map[y][x];
      if(tile==="#"){ ctx.drawImage(spriteTiles, 16,0,16,16,x*TILE,y*TILE,TILE,TILE);}
      else if(tile==">"||tile=="<"){ ctx.drawImage(spriteTiles, 32,0,16,16,x*TILE,y*TILE,TILE,TILE);}
      else{ ctx.drawImage(spriteTiles,0,0,16,16,x*TILE,y*TILE,TILE,TILE);}
    }
  }
}

function drawItems(){
  items.forEach(item=>{
    if(item.room!==currentMap) return;
    ctx.drawImage(spriteObjects,0,0,16,16,item.x,item.y,TILE,TILE);
  });
}

function drawNPCs(){
  npcs.forEach(npc=>{
    if(npc.room!==currentMap) return;
    ctx.drawImage(spriteNPC,0,0,16,16,npc.x,npc.y,TILE,TILE);
  });
}

function drawPlayer(){
  ctx.drawImage(spritePlayer, player.frame*16,0,16,16, player.x, player.y, TILE, TILE);
}

loop();
